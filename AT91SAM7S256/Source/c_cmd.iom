//
// Date init       14.12.2004
//
// Revision date   $Date: 3-02-09 9:28 $
//
// Filename        $Workfile:: c_cmd.iom                                     $
//
// Version         $Revision: 5 $
//
// Archive         $Archive:: /LMS2006/Sys01/Main_V02/Firmware/Source/c_cmd. $
//
// Platform        C
//

#ifndef   CCMD_IOM
#define   CCMD_IOM

#include "modules.h"

#define   pMapCmd ((IOMAPCMD*)(pHeaders[ENTRY_CMD]->pIOMap))

//
// Status/error codes for the VM internal code and bytecodes, loosely categorized
// Positive values are used for non-error status codes; commonly used by bytecode handlers
//  to affect future execution.
// Negative values are run-time errors, and the first group is considered "fatal" in that
//  program execution cannot continue when these errors are encountered.
//

#define STAT_MSG_EMPTY_MAILBOX 64 //0x40 Specified mailbox contains no new messages
#define STAT_MSG_BUFFERWRAP 16 //0x10 Datalog buffer not being read fast enough
#define STAT_COMM_PENDING 32 //0x20 Pending setup operation in progress

#define TIMES_UP       6 //0x06 Return to let drivers run
#define ROTATE_QUEUE  5 //0x05 Give a slice to another queue
#define STOP_REQ      4 //0x04 Abort current program
#define BREAKOUT_REQ  3 //0x03 Break multi-instruction interpreter loop; give I/O a chance to run
#define CLUMP_SUSPEND 2 //0x02 Place clump in stasis; execute others until this one returns to RunQ
#define CLUMP_DONE    1 //0x01 Finish and reset this clump; execute others until this one is rescheduled

#define NO_ERR        0

//Fatal errors
#define ERR_ARG             -1  // 0xFF Bad arguments
#define ERR_INSTR           -2  // 0xFE Illegal bytecode instruction
#define ERR_FILE            -3  // 0xFD cCmdVerifyMemMgr() != TRUE
#define ERR_VER             -4  // 0xFC Version mismatch between firmware and compiler
#define ERR_MEM             -5  // 0xFB Insufficient memory available
#define ERR_BAD_PTR         -6  // 0xFA Someone passed us a bad pointer!

#define ERR_CLUMP_COUNT     -7  // 0xF9 (FileClumpCount == 0 || FileClumpCount >= NOT_A_CLUMP)
#define ERR_NO_CODE         -8  // 0xF8 VarsCmd.CodespaceCount == 0
#define ERR_INSANE_OFFSET   -9  // 0xF7 CurrOffset != (DataSize - VarsCmd.CodespaceCount * 2)
#define ERR_BAD_POOL_SIZE   -10 // 0xF6 VarsCmd.PoolSize > POOL_MAX_SIZE
#define ERR_LOADER_ERR      -11 // 0xF5 LOADER_ERR(LStatus) != SUCCESS || pData == NULL || DataSize == 0
#define ERR_SPOTCHECK_FAIL  -12 // 0xF4 ((UBYTE*)(VarsCmd.pCodespace) < pData) (c_cmd.c 1893)
#define ERR_NO_ACTIVE_CLUMP -13 // 0xF3 VarsCmd.RunQ.Head == NOT_A_CLUMP
#define ERR_DEFAULT_OFFSETS -14 // 0xF2 (DefaultsOffset != FileOffsets.DynamicDefaults) || (DefaultsOffset + FileOffsets.DynamicDefaultsSize != FileOffsets.DSDefaultsSize)
#define ERR_MEMMGR_FAIL     -15 // 0xF1 (UBYTE *)VarsCmd.MemMgr.pDopeVectorArray != VarsCmd.pDataspace + DV_ARRAY[0].Offset

#define ERR_NON_FATAL -16 //0xF0 or greater

//General errors
#define ERR_INVALID_PORT   -16 //0xF0 Bad input or output port specified
#define ERR_INVALID_FIELD  -17 //0xEF Attempted to access invalid field of a structure
#define ERR_INVALID_QUEUE  -18 //0xEE Illegal queue ID specified
#define ERR_INVALID_SIZE   -19 //0xED Illegal size specified
#define ERR_NO_PROG        -20 //0xEC No active program

//Communications specific errors
#define ERR_COMM_CHAN_NOT_READY -32 //0xE0 Specified channel/connection not configured or busy
#define ERR_COMM_CHAN_INVALID   -33 //0xDF Specified channel/connection is not valid
#define ERR_COMM_BUFFER_FULL    -34 //0xDE No room in comm buffer
#define ERR_COMM_BUS_ERR        -35 //0xDD Something went wrong on the communications bus

//Remote control ("direct commands") errors
#define ERR_RC_ILLEGAL_VAL -64 //0xC0 Data contains out-of-range values
#define ERR_RC_BAD_PACKET  -65 //0xBF Clearly insane packet
#define ERR_RC_UNKNOWN_CMD -66 //0xBE Unknown command opcode
#define ERR_RC_FAILED      -67 //0xBD Request failed (i.e. specified file not found)

//NB: Error codes -96 through -128 (0xA0 through 0x80) reserved for loader (file system) errors
//This whole range isn't actually used by current loader code, but it's a reasonable range to reserve

#define IS_ERR(Status)   ((Status) < NO_ERR)

//Errors are considered fatal if they are something we'd consider halting the VM for.
#define IS_FATAL(Status) ((Status) < NO_ERR && (Status) > ERR_NON_FATAL)

//Direct command protocol opcodes
//!!! These MUST be mutually exclusive with c_comm's protocol opcodes.
// Since all of c_comm's protocol opcodes are above 0x80, we're safe for now.
enum
{
  RC_START_PROGRAM,
  RC_STOP_PROGRAM,
  RC_PLAY_SOUND_FILE,
  RC_PLAY_TONE,
  RC_SET_OUT_STATE,
  RC_SET_IN_MODE,
  RC_GET_OUT_STATE,
  RC_GET_IN_VALS,
  RC_RESET_IN_VAL,
  RC_MESSAGE_WRITE,
  RC_RESET_POSITION,
  RC_GET_BATT_LVL,
  RC_STOP_SOUND,
  RC_KEEP_ALIVE,
  RC_LS_GET_STATUS,
  RC_LS_WRITE,
  RC_LS_READ,
  RC_GET_CURR_PROGRAM,
  RC_GET_BUTTON_STATE,
  RC_MESSAGE_READ,
  RC_RESERVED1,
  RC_RESERVED2,
  RC_RESERVED3,
  RC_RESERVED4,
  RC_RESERVED5,
  RC_DATALOG_READ,
  RC_DATALOG_SET_TIMES,
  RC_BT_GET_CONTACT_COUNT,
  RC_BT_GET_CONTACT_NAME,
  RC_BT_GET_CONN_COUNT,
  RC_BT_GET_CONN_NAME,
  RC_SET_PROPERTY,
  RC_GET_PROPERTY,
  RC_UPDATE_RESET_COUNT,
  RC_SET_VM_STATE,
  RC_GET_VM_STATE,
  RC_SET_BREAKPOINTS,
  RC_GET_BREAKPOINTS,
  NUM_RC_OPCODES
};

// selectors for RC Get and Set properties
enum {
RC_PROP_BTONOFF,
RC_PROP_SOUND_LEVEL,
RC_PROP_SLEEP_TIMEOUT,
RC_PROP_DEBUGGING = 0xF
};

#define RC_PORTS_AB  0xFC
#define RC_PORTS_AC  0xFD
#define RC_PORTS_BC  0xFE
#define RC_PORTS_ALL 0xFF

#define RC_OUT_AB  0x03
#define RC_OUT_AC  0x04
#define RC_OUT_BC  0x05
#define RC_OUT_ABC 0x06

//
//Published status of last program to be activated
//This value is published so outside parties (like the UI) can check if a program is running,
//and if not, how the last program ended.  Initial value is "PROG_OK".
//PROG_OK: Last program finished normally.
//PROG_RUNNING: Program currently running
//PROG_ERROR: Last program ended because of an error
//PROG_ABORT: Last program ended because of (user) abort
//

typedef SBYTE PROGRAM_STATUS;
#define PROG_IDLE    0x00
#define PROG_OK      0x01
#define PROG_RUNNING 0x02
#define PROG_ERROR   0x03
#define PROG_ABORT   0x04
#define PROG_RESET   0x05
/*
typedef enum
{
  PROG_IDLE,
  PROG_OK,
  PROG_RUNNING,
  PROG_ERROR,
  PROG_ABORT,
  PROG_RESET
} PROGRAM_STATUS;
*/
//Maximum size of memory pool, in bytes
//!!! Code assumes this value is evenly divisible by 4!
#define POOL_MAX_SIZE 32768

//Versioning information
//Format string must exist verbatim in the header of a valid program file.
//Also included in IOMAPCMD for remote identification of the VM
#define VM_FORMAT_STRING "MindstormsNXT"
//Size of format string above, plus version number packed in the last two bytes.
#define VM_FORMAT_STRING_SIZE 16
//Current firmware version defined in c_loader.iom as FIRMWAREVERSION
//This is the oldest compatible version in the same system
#define VM_OLDEST_COMPATIBLE_VERSION 0x0004
//
//IO Map for Command Module
// pRCHandler: Function pointer to handler for remote control protocol
// Tick:       Latest value from 1 ms system timer

//!!! Two offset values below are useful for external debugging.  They are only valid after a program has started!
// OffsetDS: Offset to the dataspace (inside MemoryPool); relative to first byte of IOMapCmd
// OffsetDVA: Offset to the DopeVectorArray (inside MemoryPool); relative to first byte of IOMapCmd

// ProgStatus: Published status of last program to be activated
// Awake:      Boolean is only true after initialization

// ActivateFlag: Set this flag to notify cCmdCtrl to activate new file
// DeactivateFlag: Set this flag to notify cCmdCtrl to deactivate current program

// FileName[]:   Fill in this buffer when using ActivateFlag
// MemoryPool[]: Main memory pool for program data.
//   (Declared as ULONG for portable alignment; used internally via a byte pointer.)
//
typedef struct
{
  UBYTE FormatString[VM_FORMAT_STRING_SIZE];
  UWORD (*pRCHandler)(UBYTE *, UBYTE *, UBYTE *);
  ULONG Tick;

  UWORD OffsetDS;
  UWORD OffsetDVA;

  PROGRAM_STATUS ProgStatus;

  UBYTE Awake;

  UBYTE ActivateFlag;
  UBYTE DeactivateFlag;
  UBYTE FileName[FILENAME_LENGTH + 1];

  ULONG MemoryPool[POOL_MAX_SIZE / 4];

  ULONG SyncTime;
  ULONG SyncTick;
} IOMAPCMD;

#endif //CCMD_IOM
